<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="/images/logo-square.png" type="image/x-icon">

    <title>Documentation - Dynflow</title>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- CSS -->
    <link rel="stylesheet" href="/css/app.css">

    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
    <link href='http://dynflow.github.io/atom.xml' rel='alternate' title='site_title - Atom' type='application/atom+xml'>
</head>
<body>

<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar"
                    aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
                <img src="/images/logo-square.png">
Dynflow

            </a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav">
                <!--TODO make active-->
<li><a href="/">About</a></li>
<li><a href="/documentation/">Documentation</a></li>
<li><a href="/faq/">FAQ</a></li>
<li><a href="/media/">Media</a></li>
<li><a href="/projects/">Related projects</a></li>
<!--<li class="dropdown">-->
<!--<a id="drop1" href="/documentation" class="dropdown-toggle" data-toggle="dropdown"-->
<!--aria-haspopup="true" role="button" aria-expanded="false">-->
<!--Documentation-->
<!--<span class="caret"></span>-->
<!--</a>-->
<!--<ul class="dropdown-menu" role="menu" aria-labelledby="drop1">-->
<!--<li role="presentation">-->
<!--<a role="menuitem" tabindex="-1" href="/documentation/glossary">Glossary</a>-->
<!--</li>-->
<!--&lt;!&ndash;<li role="presentation" class="divider"></li>&ndash;&gt;-->
<!--</ul>-->
<!--</li>-->

            </ul>
            <ul class="nav navbar-nav navbar-right">
                <!--<li><a class="extra" href="/atom.xml">RSS</a></li>-->

            </ul>
        </div>
    </div>
</nav>

<div class="container">
    <div class="row">

    
    <div class="col-md-4">
                <div class="toc well" data-spy="affix" data-offset-top="0" data-offset-bottom="0">
          <h4>Table of content</h4>
          <ul>
<li>
<a href="#high-level-overview-todo">High level overview TODO</a>
</li>
<li>
<a href="#glossary">Glossary</a>
</li>
<li>
<a href="#examples">Examples</a>
</li>
<li>
<a href="#how-to-use">How to use</a>
<ul>
<li>
<a href="#world-creation-todo">World creation TODO</a>
</li>
<li>
<a href="#development-vs-production">Development vs production</a>
</li>
<li>
<a href="#action-anatomy">Action anatomy</a>
<ul>
<li>
<a href="#input-and-output">Input and Output</a>
</li>
<li>
<a href="#triggering">Triggering</a>
</li>
<li>
<a href="#plan-phase">Plan phase</a>
</li>
<li>
<a href="#run-phase">Run phase</a>
</li>
<li>
<a href="#finale-phase">Finale phase</a>
</li>
</ul>
</li>
<li>
<a href="#dependencies">Dependencies</a>
</li>
<li>
<a href="#database-and-transactions">Database and Transactions</a>
</li>
<li>
<a href="#composition">Composition</a>
</li>
<li>
<a href="#subscriptions">Subscriptions</a>
</li>
<li>
<a href="#suspending">Suspending</a>
</li>
<li>
<a href="#polling">Polling</a>
</li>
<li>
<a href="#states">States</a>
</li>
<li>
<a href="#error-handling">Error handling</a>
<ul>
<li>
<a href="#rescue-strategy-todo">Rescue strategy TODO</a>
</li>
</ul>
</li>
<li>
<a href="#console-todo">Console TODO</a>
</li>
<li>
<a href="#testing-todo">Testing TODO</a>
</li>
<li>
<a href="#long-running-actions">Long-running actions</a>
</li>
<li>
<a href="#middleware">Middleware</a>
</li>
<li>
<a href="#sub-plans">Sub-plans</a>
</li>
</ul>
</li>
<li>
<a href="#how-it-works-todo">How it works TODO</a>
<ul>
<li>
<a href="#action-states-todo">Action states TODO</a>
</li>
<li>
<a href="#the-world-anatomy">The world anatomy</a>
</li>
<li>
<a href="#client-world-vs.-executor-world">Client world vs. executor world</a>
</li>
<li>
<a href="#single-database-model">Single-database model</a>
</li>
<li>
<a href="#inner-world-communication">Inner-world communication</a>
</li>
<li>
<a href="#persistence">Persistence</a>
</li>
<li>
<a href="#connector">Connector</a>
<ul>
<li>
<a href="#load-balancing">Load-balancing</a>
</li>
</ul>
</li>
<li>
<a href="#coordinator">Coordinator</a>
</li>
<li>
<a href="#thread-pools-todo">Thread-pools TODO</a>
</li>
<li>
<a href="#suspending-->-events-todo">Suspending -&gt; events TODO</a>
</li>
</ul>
</li>
<li>
<a href="#use-cases-todo">Use cases TODO</a>
</li>
<li>
<a href="#comments">Comments</a>
</li>
</ul>

        </div>

    </div>
    

    <div class="col-md-8">

        <div class="page">
            
            <h1 class="countheads">Documentation</h1>
            

            <div class=" alert alert-danger">
  <p><strong>Danger</strong> </p>

<p>Work in progress! It contains a lot of tpyos, please let us know. There are comments at the bottom
or you can submit a PR against <a href="https://github.com/dynflow/dynflow/tree/pages">pages branch</a>.</p>

<p>Please help with the documentation if you know Dynflow.</p>

<p>Thanks!</p>

</div>

<h2 id="high-level-overview-todo">High level overview TODO</h2>

<p><em>TODO to be refined</em></p>

<p>Dynflow (<strong>DYN</strong>amic work<strong>FLOW</strong>) is a workflow engine
written in Ruby that allows to:</p>

<ul>
<li>  Keep track of the progress of running processes</li>
<li>  Run the code asynchronously</li>
<li>  Resume the process when something goes wrong, skip some steps when needed</li>
<li>  Detect independent parts and run them concurrently</li>
<li>  Compose simple actions into more complex scenarios</li>
<li>  Extend the workflows from third-party libraries</li>
<li>  Keep consistency between local transactional database and
external services</li>
<li>  Suspend the long-running steps, not blocking the thread pool</li>
<li>  Cancel steps when possible</li>
<li>  Extend the actions behavior with middlewares</li>
<li>  Pick different adapters to provide: storage backend, transactions, or executor implementation</li>
</ul>

<p>Dynflow has been developed to be able to support orchestration of services in the
<a href="http://katello.org">Katello</a> and <a href="http://theforeman.org/">Foreman</a> projects.</p>

<p><em>TODO</em></p>

<ul>
<li>  what problems does Dynflow solve?</li>
<li>  maybe a little history</li>
</ul>

<h2 id="glossary">Glossary</h2>

<ul>
<li>  <strong>Action</strong> - building block of execution plans, a Ruby class inherited
from <code>Dynflow::Action</code>, defines code to be run in each phase.</li>
<li>  <strong>Phase</strong> - Each action has three phases: <code>plan</code>, <code>run</code>, <code>finalize</code>.</li>
<li>  <strong>Input</strong> - A <code>Hash</code> of data coming to the action.</li>
<li>  <strong>Output</strong> - A <code>Hash</code> of data that the action produces. It&#39;s
persisted and can be used as input of other actions.</li>
<li>  <strong>Execution plan</strong> - definition of the workflow: product of the plan phase,</li>
<li>  <strong>Triggering an action</strong> - entering the plan phase, starting with the plan
method of the action. The execution follows immediately.</li>
<li>  <strong>Flow</strong> - definition of the <code>run</code>/<code>finalize</code> phase, holding the information
about steps that can run concurrently/in sequence. Part of execution plan.</li>
<li>  <strong>Executor</strong> - service that executes the run and finalize flows based on
the execution plan. It can run in the same process as the plan phase or in
different process (using the remote executor).</li>
<li>  <strong>World</strong> - the universe where the Dynflow runs the code: it holds all
needed configuration. Usually there&#39;s only one world per Dynflow process,
besides configuration it also holds <code>Persistence</code>, <code>Logger</code>, <code>Executor</code> and
all the other objects necessary for action executing. This concept
allows us to avoid globally shared state. Also, the worlds can
talk to each other, which is helpful for production and
high-availability setups,
having multiple worlds on different hosts handle the execution of the execution plans.</li>
</ul>

<h2 id="examples">Examples</h2>

<p>See the
<a href="https://github.com/Dynflow/dynflow/tree/master/examples">examples directory</a>
for the code in action. Running those files (except the
<code>example_helper.rb</code> file) leads to the Dynflow runtime being initialized
(including the web console where one can explore the features and
experiment).</p>

<p><em>TODO</em></p>

<ul>
<li>  for async operations</li>
<li>  for orchestrating system/ssh calls</li>
<li>  for keeping consistency between local database and external systems</li>
<li>  sub-tasks</li>
</ul>

<h2 id="how-to-use">How to use</h2>

<h3 id="world-creation-todo">World creation TODO</h3>

<ul>
<li>  <em>include executor description</em></li>
</ul>

<h3 id="development-vs-production">Development vs production</h3>

<ul>
<li>  <em>In development execution runs in the same process, in production there is an
executor process.</em></li>
</ul>

<p><em>TODO</em></p>

<h3 id="action-anatomy">Action anatomy</h3>

<div class="graphviz-wrapper">

<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: Graphviz Pages: 1 -->
<svg role="img" aria-label="" width="376pt" height="44pt"
 viewBox="0.00 0.00 376.09 44.00"  >
<title></title>
<desc>digraph &quot;Graphviz&quot; { 
rankdir=LR
Trigger -&gt; Plan -&gt; Run -&gt; Finalize
 }</desc>

<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<title>Graphviz</title>
<polygon fill="transparent" stroke="none" points="-4,4 -4,-40 372.087,-40 372.087,4 -4,4"/>
<!-- Trigger -->
<g id="node1" class="node"><title>Trigger</title>
<ellipse fill="none" stroke="black" cx="37.0467" cy="-18" rx="37.0935" ry="18"/>
<text text-anchor="middle" x="37.0467" y="-14.3" font-family="Times,serif" font-size="14.00">Trigger</text>
</g>
<!-- Plan -->
<g id="node2" class="node"><title>Plan</title>
<ellipse fill="none" stroke="black" cx="137.093" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="137.093" y="-14.3" font-family="Times,serif" font-size="14.00">Plan</text>
</g>
<!-- Trigger&#45;&gt;Plan -->
<g id="edge1" class="edge"><title>Trigger&#45;&gt;Plan</title>
<path fill="none" stroke="black" d="M74.2771,-18C82.562,-18 91.371,-18 99.6641,-18"/>
<polygon fill="black" stroke="black" points="99.8147,-21.5001 109.815,-18 99.8146,-14.5001 99.8147,-21.5001"/>
</g>
<!-- Run -->
<g id="node3" class="node"><title>Run</title>
<ellipse fill="none" stroke="black" cx="227.093" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="227.093" y="-14.3" font-family="Times,serif" font-size="14.00">Run</text>
</g>
<!-- Plan&#45;&gt;Run -->
<g id="edge2" class="edge"><title>Plan&#45;&gt;Run</title>
<path fill="none" stroke="black" d="M164.496,-18C172.487,-18 181.404,-18 189.918,-18"/>
<polygon fill="black" stroke="black" points="190.012,-21.5001 200.012,-18 190.012,-14.5001 190.012,-21.5001"/>
</g>
<!-- Finalize -->
<g id="node4" class="node"><title>Finalize</title>
<ellipse fill="none" stroke="black" cx="329.09" cy="-18" rx="38.9931" ry="18"/>
<text text-anchor="middle" x="329.09" y="-14.3" font-family="Times,serif" font-size="14.00">Finalize</text>
</g>
<!-- Run&#45;&gt;Finalize -->
<g id="edge3" class="edge"><title>Run&#45;&gt;Finalize</title>
<path fill="none" stroke="black" d="M254.105,-18C261.925,-18 270.77,-18 279.555,-18"/>
<polygon fill="black" stroke="black" points="279.775,-21.5001 289.775,-18 279.775,-14.5001 279.775,-21.5001"/>
</g>
</g>
</svg>
</div>

<p>When action is triggered, Dynflow executes plan method on this action, which
is responsible for building the execution plan. It builds the execution plan by calling
<code>plan_action</code> and <code>plan_self</code> methods, effectively listing actions that should be run as
a part of this execution plan. In other words, it compiles a list of actions on which
method <code>run</code> will be called. Also it&#39;s responsible for giving these actions
an order. A simple example of such plan action might look like this</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># this would plan deletion of files passed as an input array</span>
<span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
  <span class="n">files</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">filename</span><span class="o">|</span>
    <span class="n">plan_action</span> <span class="no">MyActions</span><span class="o">::</span><span class="no">File</span><span class="o">::</span><span class="no">Destroy</span><span class="p">,</span> <span class="n">filename</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Note that it does not have to be only other actions that are planned to run.
In fact it&#39;s very common that the action plan itself, which means it will
put its own <code>run</code> method call in the execution plan. In order to do that
you can use <code>plan_self</code>. This could be used in MyActions::File::Destroy
used in previous example</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">MyActions</span><span class="o">::</span><span class="no">File</span><span class="o">::</span><span class="no">Destroy</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">plan_self</span> <span class="ss">path</span><span class="p">:</span> <span class="n">filename</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span>
    <span class="no">File</span><span class="o">.</span><span class="n">rm</span><span class="p">(</span><span class="n">input</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:path</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>In example above, it seems that <code>plan_self</code> is just shortcut to
<code>plan_action MyActions::File::Destroy, filename</code> but it&#39;s not entirely true.
Note that <code>plan_action</code> always trigger <code>plan</code> of a given action while <code>plan_self</code>
plans only the <code>run</code> of Action, so by using <code>plan_action</code> we&#39;d end up in
endless loop.</p>

<p>Also note, that run method does not take any input. In fact, it can use
<code>input</code> method that refers to arguments, that were used in <code>plan_self</code>.</p>

<p>Similar to the input mentioned above, the run produces output.
After that some finalizing steps can be taken. Actions can use outputs of other actions
as parts of their inputs establishing dependency. Action&#39;s state is serialized between each phase
and survives machine/executor restarts.</p>

<p>As lightly touched in the previous paragraph there are 3 phases: <code>plan</code>, <code>run</code>, <code>finalize</code>.
Plan phase starts by triggering an action.</p>

<h4 id="input-and-output">Input and Output</h4>

<p>Both input and output are <code>Hash</code>es accessible by <code>Action#input</code> and <code>Action#output</code> methods. They
need to be serializable to JSON so it should contain only combination of primitive Ruby types
like: <code>Hash</code>, <code>Array</code>, <code>String</code>, <code>Integer</code>, etc.</p>

<div class=" alert alert-warning">
  <p><strong>Warning</strong> </p>

<p>One should avoid using directly</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">key</span><span class="p">:</span> <span class="n">data</span> <span class="p">}</span>
</code></pre></div>
<p>It might delete other data stored in the output (potentially by middleware and other
parts of the action). Therefore it&#39;s preferred to use</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">output</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="ss">key</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="ss">another_key</span><span class="p">:</span> <span class="n">another_data</span><span class="p">)</span>
<span class="c1"># or for one key</span>
<span class="n">output</span><span class="o">[</span><span class="ss">:key</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span>
</code></pre></div>
</div>

<div class=" alert alert-info">
  <p><strong>Note</strong> </p>

<p>You may sometime find these input/output format definitions:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AnAction</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="n">input_format</span> <span class="k">do</span>
    <span class="n">param</span> <span class="ss">:id</span><span class="p">,</span> <span class="nb">Integer</span>
    <span class="n">param</span> <span class="ss">:name</span><span class="p">,</span> <span class="nb">String</span>
  <span class="k">end</span>

  <span class="n">output_format</span> <span class="k">do</span>
    <span class="n">param</span> <span class="ss">:uuid</span><span class="p">,</span> <span class="nb">String</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>This might me quite handy especially in combination with
<a href="#subscriptions">subscriptions</a> functionality.</p>

<p>The format follows <a href="https://github.com/iNecas/apipie-params">apipie-params</a> for more details.
Validations of input/output could be performed against this description but it&#39;s not turned on
by default. (It needs to be revisited and updated to be fully functional.)</p>

</div>

<h4 id="triggering">Triggering</h4>

<p>Triggering the action means starting the plan phase, followed by immediate execution.
Any action is triggered by calling:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">world_instance</span><span class="o">.</span><span class="n">trigger</span><span class="p">(</span><span class="no">AnAction</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</code></pre></div>
<div class=" alert alert-info">
  <p><strong>Note</strong> </p>

<p>In Foreman and Katello actions are usually triggered by <code>ForemanTask.sync_task</code> and
<code>ForemanTasks.async_task</code> so following part is not that important if you are using
<code>ForemanTasks</code>.</p>

</div>

<p><code>World#trigger</code> method returns object of <code>TriggerResult</code> type. Which is
<a href="http://blog.pitr.ch/projects/algebrick/">Algebrick</a> variant type where definition follows:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">TriggerResult</span> <span class="o">=</span> <span class="no">Algebrick</span><span class="o">.</span><span class="n">type</span> <span class="k">do</span>
  <span class="c1"># Returned by #trigger when planning fails.</span>
  <span class="no">PlaningFailed</span>   <span class="o">=</span> <span class="n">type</span> <span class="p">{</span> <span class="n">fields!</span> <span class="ss">execution_plan_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="ss">error</span><span class="p">:</span> <span class="no">Exception</span> <span class="p">}</span>
  <span class="c1"># Returned by #trigger when planning is successful but execution fails to start.</span>
  <span class="no">ExecutionFailed</span> <span class="o">=</span> <span class="n">type</span> <span class="p">{</span> <span class="n">fields!</span> <span class="ss">execution_plan_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="ss">error</span><span class="p">:</span> <span class="no">Exception</span> <span class="p">}</span>
  <span class="c1"># Returned by #trigger when planning is successful, #future will resolve after</span>
  <span class="c1"># ExecutionPlan is executed.</span>
  <span class="no">Triggered</span>       <span class="o">=</span> <span class="n">type</span> <span class="p">{</span> <span class="n">fields!</span> <span class="ss">execution_plan_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="ss">future</span><span class="p">:</span> <span class="no">Future</span> <span class="p">}</span>

  <span class="n">variants</span> <span class="no">PlaningFailed</span><span class="p">,</span> <span class="no">ExecutionFailed</span><span class="p">,</span> <span class="no">Triggered</span>
<span class="k">end</span>
</code></pre></div>
<p>If you do not know <code>Algebrick</code> you can think about these as <code>Struct</code>s with types.
You can see how it&#39;s used to distinguish all the possible results
<a href="https://github.com/theforeman/foreman-tasks/blob/master/lib/foreman_tasks.rb#L20-L32">in ForemanTasks module</a>.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">trigger_task</span><span class="p">(</span><span class="n">async</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="no">Match</span><span class="o">!</span> <span class="n">async</span><span class="p">,</span> <span class="kp">true</span><span class="p">,</span> <span class="kp">false</span>

  <span class="n">match</span> <span class="n">trigger</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">),</span>
        <span class="c1"># Raise if there is any error caused either by failed planning or</span>
        <span class="c1"># by faild start of execution.</span>
        <span class="p">(</span><span class="n">on</span> <span class="o">::</span><span class="no">Dynflow</span><span class="o">::</span><span class="no">World</span><span class="o">::</span><span class="no">PlaningFailed</span><span class="o">.</span><span class="p">(</span><span class="ss">error</span><span class="p">:</span> <span class="o">~</span><span class="n">any</span><span class="p">)</span> <span class="o">|</span>
                <span class="o">::</span><span class="no">Dynflow</span><span class="o">::</span><span class="no">World</span><span class="o">::</span><span class="no">ExecutionFailed</span><span class="o">.</span><span class="p">(</span><span class="ss">error</span><span class="p">:</span> <span class="o">~</span><span class="n">any</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">error</span><span class="o">|</span>
          <span class="k">raise</span> <span class="n">error</span>
        <span class="k">end</span><span class="p">),</span>
        <span class="c1"># Succesfully triggered.</span>
        <span class="p">(</span><span class="n">on</span> <span class="o">::</span><span class="no">Dynflow</span><span class="o">::</span><span class="no">World</span><span class="o">::</span><span class="no">Triggered</span><span class="o">.</span><span class="p">(</span>
              <span class="ss">execution_plan_id</span><span class="p">:</span> <span class="o">~</span><span class="n">any</span><span class="p">,</span> <span class="ss">future</span><span class="p">:</span> <span class="o">~</span><span class="n">any</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">finished</span><span class="o">|</span>
          <span class="c1"># block on the finished Future if this is called synchronously</span>
          <span class="n">finished</span><span class="o">.</span><span class="n">wait</span> <span class="k">if</span> <span class="n">async</span> <span class="o">==</span> <span class="kp">false</span>
          <span class="k">return</span> <span class="no">ForemanTasks</span><span class="o">::</span><span class="no">Task</span><span class="o">::</span><span class="no">DynflowTask</span><span class="o">.</span><span class="n">find_by_external_id!</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<h4 id="plan-phase">Plan phase</h4>

<p>Planning always uses the thread triggering the action. Plan phase
configures action&#39;s input for run phase. It starts by executing
<code>plan</code> method of the action instance passing in arguments from
<code>World#trigger method</code></p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">world_instance</span><span class="o">.</span><span class="n">trigger</span><span class="p">(</span><span class="no">AnAction</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="c1"># executes following</span>
<span class="n">an_action</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="c1"># an_action is AnAction</span>
</code></pre></div>
<p><code>plan</code> method is inherited from Dynflow::Action and by default it plans itself if
<code>run</code> method is present using first argument as input.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AnAction</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="k">def</span> <span class="nf">run</span>
    <span class="n">output</span><span class="o">.</span><span class="n">update</span> <span class="nb">self</span><span class="o">.</span><span class="n">input</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">world_instance</span><span class="o">.</span><span class="n">trigger</span> <span class="no">AnAction</span><span class="p">,</span> <span class="ss">data</span><span class="p">:</span> <span class="s1">&#39;nothing&#39;</span>
</code></pre></div>
<p>The above will just plan itself copying input to output in run phase.</p>

<p>In most cases the <code>plan</code> method is overridden to plan self with transformed arguments and/or
to plan other actions. In the Rails application, the arguments of the
plan phase are often the ActiveRecord objects, that are then
used to produce the inputs for the actions.</p>

<p>Let&#39;s look at the argument transformation first:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AnAction</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="n">any_array</span><span class="p">)</span>
    <span class="c1"># pick just numbers</span>
    <span class="n">plan_self</span> <span class="ss">numbers</span><span class="p">:</span> <span class="n">any_array</span><span class="o">.</span><span class="n">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="n">v</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Number</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span>
    <span class="c1"># compute sum - simulating a time consuming operation</span>
    <span class="n">output</span><span class="o">.</span><span class="n">update</span> <span class="ss">sum</span><span class="p">:</span> <span class="n">input</span><span class="o">[</span><span class="ss">:numbers</span><span class="o">].</span><span class="n">reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:+</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<div class=" alert alert-info">
  <p><strong>Note</strong> </p>

<p>It&#39;s considered a good practice to use the just enough data for the
input for the action to perform the job. That means not too much
(such as using ActiveRecord&#39;s attributes), as it might have
performance impact as well as causes issues when changing the
attributes later.</p>

<p>On the other hand, the input should contain enough data to perform
the job without the need for reaching to external sources. Therefore,
instead of passing just the ActiveRecord id and loading the whole
record again in run phase, just to use some attributes, it&#39;s better to
use these attributes directly as input of the action.</p>

<p>Following theses rules should lead to the best results, both from
readability and performance point of view.</p>

</div>

<p>Now let&#39;s see an example with action planning:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">SumNumbers</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
    <span class="n">plan_self</span> <span class="ss">numbers</span><span class="p">:</span> <span class="n">numbers</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span>
    <span class="n">output</span><span class="o">.</span><span class="n">update</span> <span class="ss">sum</span><span class="p">:</span> <span class="n">input</span><span class="o">[</span><span class="ss">:numbers</span><span class="o">].</span><span class="n">reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:+</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SumManyNumbers</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
    <span class="c1"># references to planned actions</span>
    <span class="n">planned_sub_sum_actions</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">each_slice</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">numbers</span><span class="o">|</span>
      <span class="n">plan_action</span> <span class="no">SumNumbers</span><span class="p">,</span> <span class="n">numbers</span>
    <span class="k">end</span>

    <span class="c1"># prepare array of output references where each points to sum in the</span>
    <span class="c1"># output of particular action</span>
    <span class="n">sub_sums</span> <span class="o">=</span> <span class="n">planned_sub_sum_actions</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">action</span><span class="o">|</span>
      <span class="n">action</span><span class="o">.</span><span class="n">output</span><span class="o">[</span><span class="ss">:sum</span><span class="o">]</span>
    <span class="k">end</span>

    <span class="c1"># plan one last action which will sum the sub_sums</span>
    <span class="c1"># it depends on all planned_sub_sum_actions because it uses theirs outputs</span>
    <span class="n">plan_action</span> <span class="no">SumNumbers</span><span class="p">,</span> <span class="n">sub_sums</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">world_instance</span><span class="o">.</span><span class="n">trigger</span> <span class="no">SumManyNumbers</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>
</code></pre></div>
<p>Above example will in parallel sum numbers by slices of 10 values: first action sums <code>1..10</code>,
second action sums <code>11..20</code>, ..., tenth action sums <code>91..100</code>. After all sub sums are computed
one final action sums the sub sums into final sum.</p>

<div class=" alert alert-warning">
  <p><strong>Warning</strong> </p>

<p>This example is here to demonstrate the planning abilities. In reality this parallelization of
compute intensive tasks does not have a positive effect on Dynflow running on MRI. The pool of
workers may starve. It is not a big issue since Dynflow is mainly used to orchestrate external
services.</p>

<p><em>TODO add link to detail explanation in How it works when available.</em></p>

</div>

<p>Action may access local DB in plan phase,
see <a href="#database-and-transactions">Database and Transactions</a>.</p>

<h4 id="run-phase">Run phase</h4>

<p>Actions has a run phase if there is <code>run</code> method implemented.
(There may be actions just planning other actions.)</p>

<p>The run method implements the main piece of work done by this action converting
input into output. Input is immutable in this phase. It&#39;s the right place for all the steps
which are likely to fail. Action <code>run</code> phase are allowed to have side effects like: file operations,
calls to other systems, etc.
Local DB should not be accessed in this phase,
see <a href="#database-and-transactions">Database and Transactions</a></p>

<h4 id="finale-phase">Finale phase</h4>

<p>Main purpose of <code>finalize</code> phase is to be able access local DB after action finishes
successfully, like: indexing based on new data, updating records as fully created, etc.
Finalize phase does not modify input or output of the action.
Action may access local DB in <code>finalize</code> phase and must be <strong>idempotent</strong>,
see <a href="#database-and-transactions">Database and Transactions</a>.</p>

<h3 id="dependencies">Dependencies</h3>

<p>As already mentioned, actions can use output of different actions as their input (or just parts).
When they do it creates dependency between actions, which is automatically detected
by Dynflow and the execution plan is built accordingly.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">plan</span>
  <span class="n">first_action</span>  <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span>
  <span class="n">second_action</span> <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span><span class="p">,</span> <span class="n">first_action</span><span class="o">.</span><span class="n">output</span><span class="o">[</span><span class="ss">:a_key_in_output</span><span class="o">]</span>
<span class="k">end</span>
</code></pre></div>
<p><code>second_action</code> uses part of the <code>first_action</code>&#39;s output
therefore it depends on the <code>first_action</code>.</p>

<p>If actions are planned without this dependency as follows</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">plan</span>
  <span class="n">first_action</span>  <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span>
  <span class="n">second_action</span> <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span>
<span class="k">end</span>
</code></pre></div>
<p>then they are independent and they are executed concurrently.</p>

<p>There is also other mechanism how to describe dependencies between actions than just
the one based on output usage. Dynflow user can specify the order between planned
actions with DSL methods <code>sequence</code> and <code>concurrence</code>. Both methods are taking blocks
and they specify how actions planned inside the block
(or inner <code>sequence</code> and <code>concurrence</code> blocks) should be executed.</p>

<p>By default <code>plan</code> considers its space as inside <code>concurrence</code>. Which means</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">plan</span>
  <span class="n">first_action</span>  <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span>
  <span class="n">second_action</span> <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span>
<span class="k">end</span>
</code></pre></div>
<p>equals</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">plan</span>
  <span class="n">concurrence</span> <span class="k">do</span>
    <span class="n">first_action</span>  <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span>
    <span class="n">second_action</span> <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>You can establish same dependency between <code>first_action</code> and <code>second_action</code> without
using output by using <code>sequence</code></p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">plan</span>
  <span class="n">sequence</span> <span class="k">do</span>
    <span class="n">first_action</span>  <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span>
    <span class="n">second_action</span> <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>As mentioned the <code>sequence</code> and <code>concurrence</code> methods can be nested and mixed
with output usage to create more complex dependencies. Let see commented example:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">plan</span>
  <span class="c1"># Plans 3 actions of type AnAction to be executed in sequence</span>
  <span class="c1"># argument is the index in the sequence.</span>
  <span class="n">actions_executed_sequentially</span> <span class="o">=</span> <span class="n">sequence</span> <span class="k">do</span>
    <span class="mi">3</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">plan_action</span> <span class="no">AnAction</span><span class="p">,</span> <span class="n">i</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="c1"># Depends on output of the last action in `actions_executed_sequentially`</span>
  <span class="c1"># so it&#39;s added to the above sequence to be executed as 4th.</span>
  <span class="n">action1</span> <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span><span class="p">,</span> <span class="n">actions_executed_sequentially</span><span class="o">.</span><span class="n">last</span><span class="o">.</span><span class="n">output</span>

  <span class="c1"># It&#39;s planed in default plan&#39;s concurrency scope it&#39;s executed concurrently</span>
  <span class="c1"># to about four actions.</span>
  <span class="n">action2</span> <span class="o">=</span> <span class="n">plan_action</span> <span class="no">AnAction</span>
<span class="k">end</span>
</code></pre></div>
<p>The order than will be:</p>

<ul>
<li>  concurrently:

<ul>
<li>  sequentially:

<ol>
<li> <code>*actions_executed_sequentially</code></li>
<li> <code>action1</code></li>
</ol></li>
<li>  <code>action2</code></li>
</ul></li>
</ul>

<p>Let&#39;s see one more example:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">plan</span>
  <span class="n">actions</span> <span class="o">=</span> <span class="n">sequence</span> <span class="k">do</span>
    <span class="mi">2</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
      <span class="n">concurrency</span> <span class="k">do</span>
        <span class="mi">2</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">plan_action</span> <span class="no">AnAction</span><span class="p">,</span> <span class="n">i</span> <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Which results in order of execution:</p>

<ul>
<li>  sequentially:

<ol>
<li> concurrently:

<ul>
<li>  <code>actions[0][0]</code> argument: 0</li>
<li>  <code>actions[0][1]</code> argument: 0</li>
</ul></li>
<li> concurrently:

<ul>
<li>  <code>actions[1][0]</code> argument: 1</li>
<li>  <code>actions[1][1]</code> argument: 1</li>
</ul></li>
</ol></li>
</ul>

<div class=" alert alert-info">
  <p><strong>Note</strong> </p>

<p>It&#39;s on our todo-list to change that to be able to define acyclic-graph of dependencies
between the actions. <code>sequence</code> and <code>concurrence</code> methods will then be deprecated and kept
just for backward compatibility.</p>

</div>

<div class=" alert alert-warning">
  <p><strong>Warning</strong> </p>

<p>Internally dependencies are also modeled with objects representing Sequences and Concurrences,
which makes it weaker than acyclic-graph so in some cases during the dependency resolution
it might not lead into the most effective execution plan. Some actions will run in sequence even
though they could be run concurrently. This limitation is likely to be
removed in some of the further releases.</p>

</div>

<h3 id="database-and-transactions">Database and Transactions</h3>

<p>Dynflow was designed to help with orchestration of other services.
The usual execution looks as follows, we use an ActiveRecord User as example of a resource.</p>

<ol>
<li> Trigger user creation, argument is an unsaved ActiveRecord user object</li>
<li> Planning: The user is stored in local DB (in the Dynflow hosting application) within the
<code>plan</code> phase. The record is marked as incomplete.</li>
<li> Running: Operations needed for the user in external services with (e.g.) REST call.
The phase finishes when the all the external calls succeeded successfully.</li>
<li> Finalizing: The record in local DB is marked as done: ready to be
used. Potentially, saving some data that were retrieved in the <code>run</code>
phase back to the local database.</li>
</ol>

<p>For that reason there are transactions around whole <code>plan</code> and <code>finale</code> phase
(all action&#39;s plan methods are in one transaction).
If anything goes wrong in the <code>plan</code> phase any change made during planning to local DB is
reverted. Same holds for finalizing, if anything goes wrong, all changes are reverted. Therefore
all finalization methods has to be <strong>idempotent</strong>.</p>

<p>Internally Dynflow uses Sequel as its ORM, but users may choose what they need
to access they data. There is an interface <code>TransactionAdapters::Abstract</code> where its
implementations may provide transactions using different ORMs.
The most common one probably being <code>TransactionAdapters::ActiveRecord</code>.</p>

<p>So in the above example 2. and 4. step would be wrapped in <code>ActiveRecord</code> transaction
if <code>TransactionAdapters::ActiveRecord</code> is used.</p>

<p>Second outcome of the design is convention when actions should be accessing local Database:</p>

<ul>
<li>  <strong>allowed</strong> - in <code>plan</code> and <code>finalize</code> phases</li>
<li>  <strong>disallowed</strong> - (or at least discouraged) in the <code>run</code> phase</li>
</ul>

<div class=" alert alert-warning">
  <p><strong>Warning</strong> </p>

<p><em>TODO warning about AR pool configuration, needs to have sufficient size</em></p>

</div>

<h3 id="composition">Composition</h3>

<p>Dynflow is designed to allow easy composition of small building blocks
called <code>Action</code>s. Typically there are actions composing smaller pieces
together and other actions doing actual steps of work as in following
example:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">CreateInfrastructure</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="k">def</span> <span class="nf">plan</span>
    <span class="n">sequence</span> <span class="k">do</span>
      <span class="n">concurrence</span> <span class="k">do</span>
        <span class="n">plan_action</span><span class="p">(</span><span class="no">CreateMachine</span><span class="p">,</span> <span class="s1">&#39;host1&#39;</span><span class="p">,</span> <span class="s1">&#39;db&#39;</span><span class="p">)</span>
        <span class="n">plan_action</span><span class="p">(</span><span class="no">CreateMachine</span><span class="p">,</span> <span class="s1">&#39;host2&#39;</span><span class="p">,</span> <span class="s1">&#39;storage&#39;</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="n">plan_action</span><span class="p">(</span><span class="no">CreateMachine</span><span class="p">,</span>
                  <span class="s1">&#39;host3&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;web_server&#39;</span><span class="p">,</span>
                  <span class="ss">:db_machine</span>      <span class="o">=&gt;</span> <span class="s1">&#39;host1&#39;</span><span class="p">,</span>
                  <span class="ss">:storage_machine</span> <span class="o">=&gt;</span> <span class="s1">&#39;host2&#39;</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Action <code>CreateInfrastructure</code> does not have a <code>run</code> method defined, it only
defines <code>plan</code> action where other actions composed together.</p>

<h3 id="subscriptions">Subscriptions</h3>

<p>Even though composing actions is quite easy and allows to decompose
business logic to small pieces it does not directly support extensions
by plugins. For that there are subscriptions.</p>

<p><code>Actions</code> can subscribe from a plugin, gem, any other library to already
loaded <code>Actions</code>, doing so they extend the planning process with self.</p>

<p>Lets look at an example starting by definition of a core action</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># This action can be extended without doing any</span>
<span class="c1"># other steps to support it.</span>
<span class="k">class</span> <span class="nc">ACoreAppAction</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
    <span class="n">plan_self</span><span class="p">(</span><span class="ss">args</span><span class="p">:</span> <span class="n">arguments</span><span class="p">)</span>
    <span class="n">plan_action</span><span class="p">(</span><span class="no">AnotherCoreAppAction</span><span class="p">,</span> <span class="n">arguments</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span>
    <span class="nb">puts</span> <span class="s2">&quot;Running core action: </span><span class="si">#{</span><span class="n">input</span><span class="o">[</span><span class="ss">:args</span><span class="o">]</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">update</span> <span class="ss">success</span><span class="p">:</span> <span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>followed by an action definition defined in a plugin/gem/etc.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">APluginAction</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="c1"># plan this action whenever ACoreAppAction action is planned</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">subscribe</span>
    <span class="no">ACoreAppAction</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
    <span class="c1"># arguments are same as in ACoreAppAction#plan</span>
    <span class="n">plan_self</span><span class="p">(</span><span class="ss">args</span><span class="p">:</span> <span class="n">arguments</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span>
    <span class="nb">puts</span> <span class="s2">&quot;Running plugin action: </span><span class="si">#{</span><span class="n">input</span><span class="o">[</span><span class="ss">:args</span><span class="o">]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Subscribed actions are planned with same arguments as action they are
subscribing to which is called <code>trigger</code>. Their plan method is called right
after planning of the triggering action finishes.</p>

<p>It&#39;s also possible to access target action and use its output which
makes it dependent (running in sequence) on triggering action.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
  <span class="n">plan_self</span> <span class="ss">trigger_success</span><span class="p">:</span> <span class="n">trigger</span><span class="o">.</span><span class="n">output</span><span class="o">[</span><span class="ss">:success</span><span class="o">]</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">run</span>
  <span class="nb">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">update</span> <span class="s1">&#39;trigger succeeded&#39;</span> <span class="k">if</span> <span class="nb">self</span><span class="o">.</span><span class="n">input</span><span class="o">[</span><span class="ss">:trigger_success</span><span class="o">]</span>
<span class="k">end</span>
</code></pre></div>
<p>Subscription is designed for extension by plugins, it should <strong>not</strong> be used
inside a single library/app-module. It would make the process definition
hard to follow (all subscribed actions would need to be looked up).</p>

<h3 id="suspending">Suspending</h3>

<p>Sometimes action represents tasks taken in different services,
(e.g. repository synchronization in <a href="http://www.pulpproject.org/">Pulp</a>).
Dynflow tries not to waste computer resources so it offers tools to free
threads to work on other actions while waiting on external tasks or events.</p>

<p>Dynflow allows actions to suspend and be woken up on external events.
Lets create a simulation of an external service before showing the example
of suspending action.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AnExternalService</span>
  <span class="k">def</span> <span class="nf">start_synchronization</span><span class="p">(</span><span class="n">report_to</span><span class="p">)</span>
    <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
      <span class="nb">sleep</span> <span class="mi">1</span>
      <span class="n">report_to</span> <span class="o">&lt;&lt;</span> <span class="ss">:done</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>The <code>AnExternalService</code> can be invoked to <code>start_synchronization</code> and it will
report back a second later to action passed in argument <code>report_to</code>. It sends
event <code>:done</code> back by <code>&lt;&lt;</code> method.</p>

<p>Lets look at an action example.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AnAction</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="no">EXTERNAL_SERVICE</span> <span class="o">=</span> <span class="no">AnExternalService</span><span class="o">.</span><span class="n">new</span>

  <span class="k">def</span> <span class="nf">plan</span>
    <span class="n">plan_self</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">event</span>
    <span class="k">when</span> <span class="kp">nil</span> <span class="c1"># first run</span>
      <span class="n">suspend</span> <span class="k">do</span> <span class="o">|</span><span class="n">suspended_action</span><span class="o">|</span>
        <span class="no">EXTERNAL_SERVICE</span><span class="o">.</span><span class="n">start_synchronization</span> <span class="n">suspended_action</span>
      <span class="k">end</span>
    <span class="k">when</span> <span class="ss">:done</span> <span class="c1"># external task is done</span>
      <span class="n">output</span><span class="o">.</span><span class="n">update</span> <span class="ss">success</span><span class="p">:</span> <span class="kp">true</span>
      <span class="c1"># let the run phase finish normally</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="s1">&#39;unknown event&#39;</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Which is then executed as follows:</p>

<ol>
<li> <code>AnAction</code> is triggered</li>
<li> It&#39;s planned.</li>
<li> Its <code>run</code> phase begins.</li>
<li> <code>run</code> method is invoked with no event (<code>nil</code>).</li>
<li> Matches with case branch initiating the external synchronization.</li>
<li> Action initializes the synchronization and pass in reference
to suspended_action.</li>
<li> Action is suspended, execution of the run method finishes immediately
after <code>suspend</code> is called, its block parameter is evaluated right after
suspending.</li>
<li> Action is kept on memory to be woken up when events are received but it does not
block any threads.</li>
<li> Action receives <code>:done</code> event through suspend action reference.</li>
<li> <code>run</code> method is executed again with <code>:done</code> event.</li>
<li> Output is updated with <code>success: true</code> and actions finishes <code>run</code> phase.</li>
<li> There is no <code>finalize</code> phase, action is done.</li>
</ol>

<p>This event mechanism is quite flexible, it can be used for example to build a
<a href="https://github.com/Dynflow/dynflow/blob/master/lib/dynflow/action/polling.rb">polling action abstraction</a>
which is a topic for next chapter.</p>

<h3 id="polling">Polling</h3>

<p>Not all services support callbacks to be registered which would allow to wake up suspended
actions only once at the end when the external task is finished. In that case we often
need to poll the service to see if the task is still running or finished.</p>

<p>For that purpose there is <code>Polling</code> module in Dynflow. Any action can be turned into a polling one
just by including the module.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AnAction</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="kp">include</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span><span class="o">::</span><span class="no">Polling</span>
</code></pre></div>
<p>There are 3 methods need to be always implemented:</p>

<ul>
<li>  <code>done?</code> - determines when the task is complete based on external task&#39;s data.</li>
<li>  <code>invoke_external_task</code> - starts the external task.</li>
<li>  <code>poll_external_task</code> - polls the external task status data and returns a status
(JSON serializable data like: <code>Hash</code>, <code>Array</code>, <code>String</code>, etc.) which are stored in action&#39;s
output.</li>
</ul>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="k">def</span> <span class="nf">done?</span>
    <span class="n">external_task</span><span class="o">[</span><span class="ss">:progress</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">invoke_external_task</span>
    <span class="n">triger_the_task_with_rest_call</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">poll_external_task</span>
    <span class="n">data</span>     <span class="o">=</span> <span class="n">poll_data_with_rest_call</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="n">calculate_progress</span> <span class="n">data</span> <span class="c1"># =&gt; a float in 0..1</span>
    <span class="p">{</span> <span class="ss">progress</span><span class="p">:</span> <span class="n">progress</span>
      <span class="ss">data</span><span class="p">:</span>     <span class="n">data</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>This action will do following in run phase:</p>

<ol>
<li> <code>invoke_external_task</code> on first run of the action</li>
<li> suspends and then periodically:

<ol>
<li> wakes up</li>
<li> <code>poll_external_task</code></li>
<li> checks if <code>done?</code>:

<ul>
<li><code>true</code> -&gt; it concludes the run phase</li>
<li><code>false</code> -&gt; it schedules next polling</li>
</ul></li>
</ol></li>
</ol>

<p>There are 2 other methods handling external task data which can optionally overridden:</p>

<ul>
<li>  <code>external_task</code> - reads the external task&#39;s stored data, by default it reads <code>self.output[:task]</code></li>
<li>  <code>external_task=</code> - writes the the external task&#39;s stored data, by default it writes to
<code>self.output[:task] = value</code></li>
</ul>

<p>There are also other features implemented like:</p>

<ul>
<li>  Gradual prolongation of the polling interval.</li>
<li>  Retries on a poll failing.</li>
</ul>

<p>Please see the
<a href="https://github.com/Dynflow/dynflow/blob/master/lib/dynflow/action/polling.rb"><code>Polling</code> module</a>
for more details.</p>

<h3 id="states">States</h3>

<p>Each <strong>Action phase</strong> can be in one of the following states:</p>

<ul>
<li>  <strong>Pending</strong> - Not yet executed.</li>
<li>  <strong>Running</strong> - An action phase id being executed right now.</li>
<li>  <strong>Success</strong> - Execution of an action phase finished successfully.</li>
<li>  <strong>Error</strong> - There was an error during execution.</li>
<li>  <strong>Suspended</strong> - Only <code>run</code> phase, when action sleeps waiting for events to be woken up.</li>
<li>  <strong>Skipped</strong> - Failed actions can be marked as skipped allowing rest of the
execution plan to finish successfully.</li>
<li>  <strong>Skipping</strong> - Action is marked for skipping but execution plan was not yet
resumed to mark it as Skipped.</li>
</ul>

<p><strong>Execution plan</strong> has following states:</p>

<ul>
<li>  <strong>Pending</strong> - Planning did not start yet.</li>
<li>  <strong>Planning</strong> - It&#39;s being planned.</li>
<li>  <strong>Planned</strong> - It&#39;ve been planned, running phase did not start yet.</li>
<li>  <strong>Running</strong> - It&#39;s running, <code>run</code> and <code>finalize</code> phases of actions are executed.</li>
<li>  <strong>Paused</strong> - It was paused when running. Happens on error or executor restart.</li>
<li>  <strong>Stopped</strong> - Execution plan is completed.</li>
</ul>

<p><strong>Execution plan</strong> also has following results:</p>

<ul>
<li>  <strong>Success</strong> - Everything finished without error or skips.</li>
<li>  <strong>Warning</strong> - When there are skipped steps.</li>
<li>  <strong>Error</strong> - When one or more actions failed.</li>
<li>  <strong>Pending</strong> - Execution plan still runs.</li>
</ul>

<p><em>TODO how do I access such states as a programmer?</em>
<em>TODO which Action phase states are &quot;finish&quot; and which requires user interaction?</em></p>

<h3 id="error-handling">Error handling</h3>

<p>If there is an error risen in <strong><code>plan</code> phase</strong>, the error is persisted in the Action object 
for later inspection and it bubbles up in <code>World#trigger</code> method which was used to trigger 
the action leading to this error. 
If you compare it to errors raised during <code>run</code> and <code>finalize</code> phase,
there&#39;s the major difference: Those never bubble up in <code>trigger</code> because they are running
in executor not in triggering Thread, they are just persisted in Action object.</p>

<p>If there is an error in <strong><code>run</code> phase</strong>, the execution pauses. You can inspect the error in
<a href="#console">console</a>. The error may be intermittent or you may fix the problem manually. After
that the execution plan can be resumed and it&#39;ll continue by rerunning the failed action and
continuing with the rest of the actions. During fixing the problem you may also do the steps
in the actions manually, in that case the failed action can be also marked as skipped. After
resuming the skipped action is not executed and the execution plan continues with the rest.</p>

<p>If there is an error in <strong><code>finalize</code> phase</strong>, whole <code>finalize</code> phase for all the actions is
rollbacked and can be rerun when the problem is fixed by resuming.</p>

<p>If you encounter an error during run phase <code>error!</code> or usual <code>raise</code> can be used.</p>

<h4 id="rescue-strategy-todo">Rescue strategy TODO</h4>

<h3 id="console-todo">Console TODO</h3>

<ul>
<li>  <em>where to access</em></li>
<li>  <em>screenshots</em></li>
</ul>

<h3 id="testing-todo">Testing TODO</h3>

<ul>
<li>  <em>testing helper methods</em></li>
<li>  <em>examples</em></li>
<li>  <em>see <a href="https://github.com/Dynflow/dynflow/blob/master/test/testing_test.rb">testing of testing</a></em></li>
</ul>

<h3 id="long-running-actions">Long-running actions</h3>

<p>Dynflow was designed as an Orchestration tool, parallelization of heavy CPU computation tasks
was not directly considered. Even with multiple executors single execution plan always runs
on one executor, so without JRuby it wont scale well (MRI&#39;s GIL). However JRuby support
should be added soon (TODO update when merged).</p>

<p>Another problem with long-running actions are blocked worker. Executor has only a limited pool of
workers, if more of them become busy it may result in worsen performance.</p>

<p>Blocking actions for long time are also problematic.</p>

<p>Solutions are:</p>

<ul>
<li>  <strong>Using action suspending</strong> - suspending the action until a condition is met,
freeing the worker.</li>
<li>  <strong>Offloading computation</strong> - CPU heavy parts can be offloaded to different services
notifying the suspended actions when the computation is done.</li>
</ul>

<h3 id="middleware">Middleware</h3>

<p>Each action class has chain of middlewares which wrap phases of the action execution.
It&#39;s very similar to rack middlewares.
To create new middleware inherit from <code>Dynflow::Middleware</code> class. It has 5 methods which can be
overridden: <code>plan</code>, <code>run</code>, <code>finalize</code>, <code>plan_phase</code>, <code>finalize_phase</code>. Where the default
implementation for all the methods looks as following</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">pass</span> <span class="o">*</span><span class="n">args</span>
<span class="k">end</span>
</code></pre></div>
<p>When overriding user can insert code before and/or after the <code>pass</code> method which executes next
middleware in the chain or the action itself which is at the end of the chain. Most usually the
<code>pass</code> is always called somewhere in the overridden method. There may be some cases when it can
be omitted, then it&#39;ll prevent all following middlewares and action from running.</p>

<p>Some implementation examples:
<a href="https://github.com/theforeman/foreman-tasks/blob/master/app/lib/actions/middleware/keep_current_user.rb">KeepCurrentUser</a>,
<a href="https://github.com/Dynflow/dynflow/blob/master/lib/dynflow/action/progress.rb#L13-L42">Action::Progress::Calculate</a>.</p>

<p>Each Action has a chain of middlewares defined. Middleware can be added by calling <code>use</code>
in the action class.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AnAction</span> <span class="o">&lt;</span> <span class="no">Dynflow</span><span class="o">::</span><span class="no">Action</span>
  <span class="n">use</span> <span class="no">AMiddleware</span><span class="p">,</span> <span class="ss">after</span><span class="p">:</span> <span class="no">AnotherMiddleware</span>
<span class="k">end</span>
</code></pre></div>
<p>Method <code>use</code> understands 3 option keys:</p>

<ul>
<li>  <code>:before</code> - makes this middleware to be ordered before a given middleware</li>
<li>  <code>:after</code> - makes this middleware to be ordered after a given middleware</li>
<li>  <code>:replace</code> - this middleware will replace given middleware</li>
</ul>

<p>The <code>:before</code> and <code>:after</code> keys are used to build a graph from the middlewares which is then
sorted down with
<a href="http://ruby-doc.org//stdlib-2.0/libdoc/tsort/rdoc/TSort.html">topological sort</a>
to the chain of middleware execution.</p>

<h3 id="sub-plans">Sub-plans</h3>

<ul>
<li>  <em>when to use?</em></li>
<li>  <em>how to use?</em></li>
</ul>

<h2 id="how-it-works-todo">How it works TODO</h2>

<div class=" alert alert-info">
  <p><strong>Note</strong> </p>

<p>This part is based on the current work-in-progress on <a href="https://github.com/Dynflow/dynflow/pull/139">multi-executors
support</a></p>

</div>

<h3 id="action-states-todo">Action states TODO</h3>

<ul>
<li>  <em>normal phases and Present phase</em></li>
<li>  <em>how to walk the execution plan</em></li>
</ul>

<h3 id="the-world-anatomy">The world anatomy</h3>

<p>The world represents the Dynflow&#39;s run-time and it acts as an external
interface. It holds all the configuration and sub-components needed for the
Dynflow to perform its job.</p>

<p>The Dynflow worlds is composed of the following sub-components:</p>

<ol>
<li><strong>persistence</strong> - provides the durability functionality: see
<a href="#persistence">persistence</a></li>
<li><strong>coordinator</strong> - provides the coordination between worlds: see <a href="#coordinator">coordinator</a></li>
<li><strong>connector</strong> - provides messages passing between worlds: see <a href="#connector">connector</a></li>
<li><strong>executor</strong> - the run-time itself executing the execution plan. Not
every worlds has to have the executor present (there might be pure
client worlds: useful in production, see <a href="#development-vs-production">develpment vs. production</a>.</li>
<li><strong>client dispatcher</strong> - responsible for communication between
client requests and other worlds</li>
<li><strong>executor dispatcher</strong> - responsible for getting requests from
other worlds and sending the responses</li>
</ol>

<p><img src='/images/plantuml/0d37139982d9ebe321573466f734597a.png'></p>

<p>The underlying technologies are hidden behind adapters abstraction,
which allows choosing the right technology for the job, while keeping
the rest of the Dynflow intact.</p>

<h3 id="client-world-vs.-executor-world">Client world vs. executor world</h3>

<p>In the simplest case, the world handles both the client requests and
the execution itself. This is useful for small all-in-one deployments
and development.</p>

<p>In production, however, one might want to separate
the client worlds (often running in the web-server process or client
library) and the executor worlds (running as part of standalone
service). This setup makes the execution more stable and
high-available (in active-active mode).</p>

<p>There might be multiple client as well as executor worlds in the
Dynflow infrastructure.</p>

<p>The executor world has still its own client dispatcher, so that it
can act as a client for triggering other execution plans (useful in
<a href="#sub-plans">sub-plans</a> feature).</p>

<p><img src='/images/plantuml/c6e9a1751714e51c2c853ef10a47bb5a.png'></p>

<h3 id="single-database-model">Single-database model</h3>

<p>Dynflow recognizes different expectations from the underlying
technologies from the persistence (durability), coordinator (real-time
synchronization) and connector (transport).</p>

<p>However, we also realize that for many use-cases, a single shared
database is just enough infrastructure the user needs for the job.
Forcing using different technologies would mean just useless overhead.</p>

<p>Therefore, it&#39;s possible to use a single shared SQL database to do
all the work.</p>

<p><img src='/images/plantuml/82a749940f0e126c442a206969354e96.png'></p>

<div class=" alert alert-info">
  <p><strong>Note</strong> </p>

<p>Something as simple as sqlite is enough for getting the Dynlfow
up-and-running and getting something done.</p>

<p>For the best connector results, it&#39;s recommended to use PostgreSQL, as
Dynflow can utilize the
<a href="http://www.postgresql.org/docs/9.0/static/sql-notify.html">listen/notify</a>
feature for better response times.</p>

</div>

<h3 id="inner-world-communication">Inner-world communication</h3>

<p><img src='/images/plantuml/c151214d41b23172bca5c47624baed52.png'></p>

<p>1) the client prepares an execution plan, saves it into persistence
and passes its id to the client dispatcher</p>

<p>2) the client dispatcher creates an
<a href="http://www.rubydoc.info/github/ruby-concurrency/concurrent-ruby/Concurrent/IVar">IVar</a>
that represents the future value of the execution plan after it
finishes execution. The client can use this value to wait for the
execution plan to finish or hook other procedures on the finish-time.</p>

<p>3) the client dispatcher creates an envelope (see
<a href="#connector">connector</a> for more details), containing the request for
execution, with <code>receiver id</code> set to <code>AnyExecutor</code></p>

<p>4) the connector uses some scheduling algorithm to choose what executor to send the request to and
replaces the <code>AnyExecutor</code> with it. It sends the envelope the the
chosen executor.</p>

<p>5) the connector on the executor side receives the envelope and asks
the executor dispatcher to handle it</p>

<p>6) the executor dispatcher acquires the lock on the execution plan and
initiates the execution. In the mean-time, it lets the client know
that the work was accepted (there might be additional logic on the
client to handle a timeout after the work was not accepted)</p>

<p>7 - 9) the connector layer propagates the <code>Accepted</code> response back
to client</p>

<p>10) the executor finishes execution</p>

<p>11 - 12) the connector layer propagates the <code>Finished</code> response</p>

<p>13) the client dispatcher resolves the original <code>IVar</code>, so that the
client is able to find out about the finished execution.</p>

<p>The behavior is the same even in the &quot;one world&quot; scenario: in that
case this world is participating both on the client and the executor
side, connected through a direct in-memory connector.</p>

<h3 id="persistence">Persistence</h3>

<p>The persistence making sure that the serialized states of the
execution plans are persisted for recovery and status tracking. The
execution plan data are stored in it, with the actual state.</p>

<p>Unlike coordinator, the all the persisted data don&#39;t have to be
available for all the worlds at the same time: every world needs just
the data that it is actively working on. Also, all the data don&#39;t have to
be fully synchronized between worlds (as long as the up-to-date data
about relevant execution plans are available for the world).</p>

<h3 id="connector">Connector</h3>

<p>Provides messages passing between worlds. The message has a form of
envelope of the following structure:</p>

<ul>
<li><strong>sender id</strong> - the id of the world that produced the envelope</li>
<li><strong>receiver id</strong> - the id of the world that should receive the
message, or <code>AnyExecutor</code>, when load-balancing</li>
<li><strong>request id</strong> - the client-unique id used for pairing the
request - response at the client</li>
<li><strong>message</strong> - the body of the message: the connector doesn&#39;t care
about that as long as it&#39;s serializable</li>
</ul>

<h4 id="load-balancing">Load-balancing</h4>

<p>The connector is responsible for spreading the load across the
executor worlds. It&#39;s determined by the <code>AnyExecutor</code> value at the
<code>request id</code> field. The implementation available in the
current version uses a simple round-robin algorithm for this purpose.</p>

<h3 id="coordinator">Coordinator</h3>

<p>This component (especially important in a multi-executor setup): Makes
sure no two executors are executing the same execution plan at the
same time (a.k.a locking). It also provides the information
about the worlds available in the system (the worlds register). Unlike
the persistence, it&#39;s not required to persist the data (could be
recalculated), but it needs to provide a globally shared state.</p>

<p>The main type of objects the coordinator works with is a record which
consists of:</p>

<ul>
<li>type - the type of the record</li>
<li>id - the id of the record (unique in scope of a type)</li>
<li>data - data in arbitrary format, based on the type</li>
</ul>

<p>There is a special type of record called <code>lock</code>, that keeps the owner
information as well. It&#39;s used for keeping information about what
executor is actively working on what execution plan: the executor is
not allowed to start executing the unless it has successfully acquired
a lock for it.</p>

<h3 id="thread-pools-todo">Thread-pools TODO</h3>

<ul>
<li>  <em>how it works now</em></li>
<li>  <em>how it&#39;ll work</em></li>
<li>  <em>gotchas</em>

<ul>
<li>  <em>worker pool sizing</em></li>
</ul></li>
</ul>

<h3 id="suspending--&gt;-events-todo">Suspending -&gt; events TODO</h3>

<h2 id="use-cases-todo">Use cases TODO</h2>

<ul>
<li>  <em>Embedded without a DB, like inside CLI tool for a complex installation</em></li>
<li>  <em>reserve resources in planning do not try to do <code>if</code>s in run phase</em></li>
<li>  <em>Projects: katello, foreman, staypuft, fusor</em></li>
</ul>

<h2 id="comments">Comments</h2>

<p><strong>Comments are temporally turned on here for faster feedback.</strong></p>

        </div>

        

        
        <div id="disqus_thread" aria-live="polite">
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments
                powered by
                Disqus.</a></noscript>
        </div>
        

    </div>
</div>




</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="/bootstrap/js/bootstrap.min.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60290609-1', 'auto');
    ga('send', 'pageview');

</script>


<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'dynflow'; // required: replace example with your forum shortname
    var disqus_identifier = 'http://dynflow.github.io/documentation/index.html';
    var disqus_url = 'http://dynflow.github.io/documentation/index.html';
    var disqus_title = 'Dynflow';

    if ('true' == 'true')
        (function () {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    //    else
    //        (function () {
    //            var s = document.createElement('script');
    //            s.async = true;
    //            s.type = 'text/javascript';
    //            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    //            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    //        }());

</script>

<script type="text/javascript">
    (function () {
        var twitterWidgets = document.createElement('script');
        twitterWidgets.type = 'text/javascript';
        twitterWidgets.async = true;
        twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
        document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
</script>

<!-- Place this tag in your head or just before your close body tag. -->
<script src="https://apis.google.com/js/platform.js" async defer></script>

<script type="text/javascript">
    $().ready(function () {
        var scrollTo = function (target) {
            if (target.charAt(0) == '#' && $(target).length) {
                $('html,body').animate({scrollTop: $(target).offset().top - 70}, 'normal');
                return true;
            } else
                return false;
        };

        var callback = function (e) {
            var target = $(this).attr('href');
            if (scrollTo(target)) {
                e.preventDefault();
                location.hash = target;
            }
        };

        $('.toc a').on('click', callback);
        $('.page a').on('click', callback);

        scrollTo(location.hash);
    });
</script>


</body>
</html>


